#!/usr/bin/env perl
# Copyright (C) 2017â€“2020  Alex Schroeder <alex@gnu.org>

# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
# details.
#
# You should have received a copy of the GNU Affero General Public License along
# with this program. If not, see <https://www.gnu.org/licenses/>.

=encoding utf8

=head1 Lupa Pona

Lupa Pona serves the local directory as a Gemini site.

=head2 Dependencies

Perl libraries you need to install if you want to run Lupa Pona:

=over

=item L<IO::Socket::INET6>

=item L<IO::Socket::SSL>

=item L<File::Slurper>

=item L<Modern::Perl>

=item L<Net::Server>

=item L<URI::Escape>

=back

Since Lupa Pona traffic is encrypted, we need to generate a
certificate and a key. These are both stored in PEM files. To create
your own copies of these files (and you should!), use "make cert" if
you have a copy of the Makefile. If you don't, use this:

    openssl req -new -x509 -newkey ec \
    -pkeyopt ec_paramgen_curve:prime256v1 \
    -days 1825 -nodes -out cert.pem -keyout key.pem

Answer all the questions with "." except for the one about the Common Name.
There, answer "localhost" while you're still testing things. Later, use your own
domain name.

This creates a certificate and a private key, both of them unencrypted, using
eliptic curves of a particular kind, valid for five years.

You should have three files, now: F<lupa-pona>, F<cert.pem>, and
F<key.pem>. That's enough to get started! Start the server:

    perl lupa-pona

This starts the server in the foreground, for `gemini://localhost:1965`. If it
aborts, see the L</Troubleshooting> section below. If it runs, open a second
terminal and test it:

    echo gemini://localhost \
      | openssl s_client --quiet --connect localhost:1965 2>/dev/null

You should see a Gemini page starting with the following:

    20 text/gemini; charset=UTF-8
    Welcome to Lupa Pona!

Success!! ðŸ˜€ ðŸš€ðŸš€

=head2 Troubleshooting

ðŸ”¥ B<Cannot connect to SSL port 1965 on 127.0.0.1 [No such file or
directory]> ðŸ”¥ Perhaps your L<Net::Server::Proto::SSL> module is too
old? Lupa Pona comes with a separate F<lib> directory which contains a
patched version of the module. Move this directory into your working
directory where you want to run Lupa Pona and try again.

ðŸ”¥ B<SSL_cert_file cert.pem can't be used: No such file or directory>
ðŸ”¥ Perhaps you're missing the certificate (F<cert.pem>) or key file
(F<key.pem>). I<Generate your own> using the Makefile: C<make cert>
should do it.

=head2 Options

Lupa Pona uses L<Net::Server> in the background, which has a ton
options. Let's try to focus on the options you might want to use right
away.

Here's the documentation for the most useful options:

=over

=item C<--host> is the hostname to serve; the default is C<localhost> â€“ you
      probably want to pick the name of your machine, if it is reachable from
      the Internet

=item C<--port> is the port to use; the default is 1965

=item C<--log_level> is the log level to use, 0 is quiet, 1 is errors, 2 is
      warnings, 3 is info, and 4 is debug; the default is 2

=back

=head2 Running Lupa Pona as a Daemon

If you want to start Lupa Pona as a daemon, the following options come
in handy:

=over

=item C<--setsid> makes sure Lupa Pona runs as a daemon in the background

=item C<--pid_file> is the file where the process id (pid) gets written once the
      server starts up; this is useful if you run the server in the background
      and you need to kill it

=item C<--log_file> is the file to write logs into; the default is to write log
      output to the standard error (stderr)

=item C<--user> and C<--group> might come in handy if you start Lupa Pona
      using a different user

=back

=head2 Using systemd

In this case, we don't want to daemonize the process. Systemd is going to handle
that for us. There's more documentation L<available
online|https://www.freedesktop.org/software/systemd/man/systemd.service.html>.

You could create a specific user:

    sudo adduser --disabled-login --disabled-password lupa-pona

Copy Lupa Pona to C</home/lupa-pona/lupa-pona>.

Basically, this is the template for our service:

    [Unit]
    Description=Lupa Pona
    After=network.target
    [Service]
    Type=simple
    WorkingDirectory=/home/lupa-pona
    ExecStart=/home/lupa-pona/lupa-pona
    Restart=always
    User=lupa-pona
    Group=lupa-pona
    [Install]
    WantedBy=multi-user.target

Save this as F<lupa-pona.service>, and then link it:

    sudo ln -s /home/lupa-pona/lupa-pona.service /etc/systemd/system/

Reload systemd:

    sudo systemctl daemon-reload

Start Lupa Pona:

    sudo systemctl start lupa-pona

Check the log output:

    sudo journalctl --unit lupa-pona

All the files in C</home/lupa-pona> are going to be served, if the C<lupa-pona>
user can read them.

=head2 Privacy

If you increase the log level, the server will produce more output, including
information about the connections happening, like C<2020/06/29-15:35:59 CONNECT
SSL Peer: "[::1]:52730" Local: "[::1]:1965"> and the like (in this case C<::1>
is my local address so that isn't too useful but it could also be your visitor's
IP numbers, in which case you will need to tell them about it using in order to
comply with the
L<GDPR|https://en.wikipedia.org/wiki/General_Data_Protection_Regulation>.

=cut

package App::LupaPona;
use base qw(Net::Server::Fork); # any personality will do
use File::Slurper qw(read_text read_dir);
use Encode qw(encode_utf8 decode_utf8);
use Modern::Perl '2018';
use IO::Socket::SSL;
use URI::Escape;
use Pod::Text;
use utf8;

App::LupaPona->run(
  proto => 'ssl',
  SSL_cert_file => 'cert.pem',
  SSL_key_file => 'key.pem',
);

sub default_values {
  return {
    host => 'localhost',
    ipv => '*',
    port => 1965,
  };
}

sub post_configure_hook {
  my $self = shift;
  $self->log(3, "PID $$");
  $self->log(3, "Port @{$self->{server}->{port}}");
  $self->log(3, "Host " . ("@{$self->{server}->{host}}" || "*"));
}

sub process_request {
  my $self = shift;
  eval {
    my $url; # declare here so we can print it on a timeout
    local $SIG{'ALRM'} = sub {
      if ($url) {
	$self->log(1, "Timeout processing $url");
      } else {
	$self->log(1, "Timeout");
      }
      die "Timed Out!\n";
    };
    alarm(10); # timeout
    $url = <STDIN>; # no loop
    return unless $url =~ s/\r\n$//; # CR LF is mandatory
    my ($scheme, $authority, $path, $query, $fragment) =
	$url =~ m|(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?|;
    my ($host, $port) = split(/:/, $authority);
    $port ||= 1965;
    $self->log(3, "Looking at $url");
    if (not $url) {
      $self->log(4, "The URL is empty");
      say "59 URL expected\r";
    } elsif (length($url) > 1024) {
      $self->log(4, "The URL is too long");
      say "59 The URL is too long\r";
    } elsif (not $path) {
      say "31 $url/\r" ; # enforce trailing slash
    } elsif (grep { $host eq $_ } @{$self->{server}->{host}}
	     and grep { $port eq $_ } @{$self->{server}->{port}}) {
      if ($path eq "/") {
	say "20 text/gemini; charset=UTF-8\r";
	say "Welcome to Lupa Pona!";
	for (read_dir(".")) {
	  say "=> $_" if -f;
	}
      } elsif ($path =~ m!^/([^/]+)$!) {
	my $file = decode_utf8(uri_unescape($1));
	if (-f $file) {
	  say "20 text/gemini; charset=UTF-8\r";
	  print read_text($file);
	} else {
	  say "51 File not found: $file\r";
	}
      } else {
	say "51 Path not found for $url\r";
      }
    } elsif ($authority) {
      $self->log(3, "Unsupported proxy request for $url");
      say "53 Unsupported proxy request for $url\r";
    } else {
      $self->log(3, "No handler for $url");
      say "59 Don't know how to handle $url\r";
    }
    $self->log(4, "Done");
  };
  $self->log(1, "Error: $@") if $@;
}
